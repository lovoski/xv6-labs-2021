1:
call.asm中的这一行：
  24:	4635                	li	a2,13
将13参数保存到寄存器a2中

2:
从call.asm中的：
  26:	45b1                	li	a1,12
可以知道结果12直接被保存到a1寄存器中，编译器没有调用f和g函数
这两个函数由编译器内联到了代码中

3:
汇编指令中的：
0000000000000628 <printf>:
表明printf函数在地址0000000000000628

4:
  34:	5f8080e7          	jalr	1528(ra) # 628 <printf>
以上的指令会把pc+4保存到ra中，执行当前指令的时候pc值为34
执行完该指令时pc值为34+4=38

5:
输出为：
HE110 World
如果为大端，需要把i改为0x726c6400
但是57616不用变，翻译成16进制后无论大端小端都是E110

6:
输出会是一个受之前代码影响的值
由于printf会试着从a0,a1,a2获取三个参数，但是a2并不是从printf
的参数提供的，printf会直接沿用之前代码运行得到的a2值